链接文件：软链接、硬链接。
	硬链接：类unix中特有的,linux中叫符号链接。可以用来备份重要文件，不占用块空间和inode空间，但是硬链接不能跨分区。
	软链接：类似windows 的快捷方式。不占用块空间，但是占用inode空间，而且它的存在依赖于它的链接文件。
	（复制：产生一个新文件，生成一个新的inode，占用新的块）
	（移动：在同一分区下，不占用块空间，只是重新定义inode；不同分区下，会重新调整inode，分配块空间）
ln  ss  xx    对ss文件创建一个硬链接,叫xx
	-s ss  xx 对ss文件创建一个软链接,叫xx
============================================================================
磁盘分区：MBR和GPT
liunx 分区工具：fdisk
fdisk -l   查看当前的硬盘参数（分区）
fdisk /dev/sdb   给/dev/sdb进行分区
	d     删除一个分区
	l     显示能识别的分区类型
	t     改变一个分区的系统编号，通过l获取编号（只是给人看的，底层不一定）
	m     显示帮助
	n     添加一个新分区
	o     创建一个dos分区
	p     显示分区表
	q     退出，不保存配置
	u     改变显示单元
	w     保存修改并退出
	x     高级配置（专家专用）（类似对磁盘做低级格式化，不建议使用）

一个柱面（cylinder）大小为8M，分区时柱面要连续划分。
划分拓展分区时，最好把剩下的空间都划给扩展分区。因为逻辑分区是在扩展分区的基础上划分的，逻辑分区的总大小不能超过扩展分区的大小。

partprobe /dev/sdb  更新分区表
===========================================================
分区完成后，硬盘需要进行文件系统定义和挂在才能使用。所以要对系统进行格式化。

mkfs    格式化分区
	-t  ext4 /dev/sdb5   对/dev/sdb5以ext4格式进行格式化
mkfs.ext4 /dev/sdb5   对/dev/sdb5以ext4格式进行格式化

mount /dev/sdb5  /mnt    将/dev/sdb5挂载在/mnt下
	-t  文件系统类型
	-o remount，ro /dev/sdb5 重新挂载(已经挂载过，重新挂载),并且定义为只能读取
		noexec    不能执行
		ro        只读
		rw        读写

umount /dev/sdb5(/mnt)    卸载挂载的硬盘
对于卸载时进程占用，可以通过下面的指令查看是谁占用了挂载的硬件，然后可以kill等指令干掉对方
	lsof、fuser
=========================================================
fsck                        检查并且试图修复文件系统中的错误
	fsck.etx4 -fc  /dev/sdb5    强制自检
badblocks /dev/sdb5 -sv     检查磁盘坏道，并生成报告
test                        修复分区表
tune2fs                     tune2fs命令允许系统管理员调整ext2/ext3文件系统中的可该参数。
	-l：显示文件超级块内容 
	-L：设置文件系统卷标
	-m：显示文件保留块的百分比
	-U：设置文件系统的UUID
=========================================================
GPT 分区（win10 128个扩展分区）
parted     GPT分区工具
        print 显示分区信息
        mklabel 创建分区表，指明gpt
        mkpart  创建分区

/etc/fstab   这个文件用来实现自动挂载
格式：设备名称 挂载点 文件系统 默认权限 备份 fsck
挂载光盘/镜像：/root.iso   /xx  iso9660 default,loop  0 0
=========================================================
swap  类似于windows的虚拟内存的概念
个人计算机   休眠  工具 hibernate
swap分区大小必须至少和内存一样。
服务器 oracle等应用对swap有特定要求，不创建无法安装服务器。

swap划分除了安装系统过程中定义以外，在系统安装好后也可以后期再生成。有两种方式：一种基于磁盘，一种基于文件。

第一种：将另外的分区格式化成swap,mkswap
swapon  /dev/sdb1
编写/etc/fstab,添加额外的swap分区,实现自动挂载。

第二种：
dd if=/dev/zero of=fileswap bs=1M count=100   创建一个100M的文件（建议将fileswap放在/dev下，并按照其他的文件设置权限）
=========================================================
数据恢复
1、lsof
系统进程会在后台为所有的文件创建一个文件描述符（FD）
	cwd  表示当前进程在哪个目录下工作
	rtd  
	txt  表示执行的是一个代码
	mem  表示在内存中执行的
	0u   文件打开后返回的一个整数值，u表示可读写，r表示只读，w标志可写
TYPE
	FIFO  先进先出
	DIR   目录
	REG   文件
	CLK   字符文件
	BLK   块设备文件
	
lsof /var/log/messages    查看系统中被系统进程使用的文件信息
lsof |grep delete         查找最近被删除过的文件，前提是系统没有重启
根据文件描述符找到/proc/进程号/fd/对应的文件描述符进行恢复
cat 4 > /var/log/messages

2、使用软件恢复
debugfs：
r-linux:
foremost:支持的文件类型很多，但是有些文件格式不支持。
extundelete：支持ext文件系统，不支持xfs文件系统（目前没有开源的xfs的恢复软件）；不能实现同一个分区下的数据恢复。

