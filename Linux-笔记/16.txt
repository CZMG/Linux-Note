正则表达式
正则表达式是用来模糊匹配文本的规则地处理工具。

^tom    匹配开头是tom的内容
bob$    匹配尾部是bob的内容
.       匹配任意一个字符
[]      匹配字符中包含的某一个内容，例:to[am]匹配toa和tom
	[^]     9[^78],不能匹配97和98
	[-]     9[0-6],可以匹配80-86,87不能匹配
?       匹配前面的项目0-1次，例：to?m可以匹配tom和toom
+       匹配前面的项目n次(包括0)
*       匹配前面的项目n次(.*包含没有.)
()      创建一个用于匹配的子串，例:ma(irt)?x可以表示mairtx,max
{n}     [0-9]{3}最多可以表示[0-9][0-9][0-9]
{n,m}   至少匹配n次，最多m次
|       aaa{1st|2nd}匹配aaa1st和aaa2nd

grep sbin.. passwd --color  
grep nologin$ passwd  --color  
grep 'var.*' passwd --color   :          匹配var和var*
grep -E 'nologin.*' passwd  --color  ： +是元字符，需要用-E

*、+ ：贪婪型元字符，匹配时用作最长匹配。
?    : 懒惰匹配，1次。

egrep '^[^as]..' passwd --color

\<     匹配一个单词的开头
\>     匹配一个单词的结尾
\b单词\b  精确定位只包含指定单词的行，前后不含其它字符
=================================================
正则表达式做标签
先定义一个符合规则地标签，然后可以在后面引用这个标签的内容。
\(\)   做标签

\{n\} 对出现的字符进行限制

grep -E和grep -P中可以用\d等同于[0-9]。
==============================================
国际字符
grep "[[:digit:]]" \
=============================================
regexper.com    可视化网站
============================================
邮箱
grep -E '[A-Za-z0-9_]+@[A-Za-z0-9_]+(\.[a-z]+)+' 2.txt --color
